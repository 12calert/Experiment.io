{% extends 'base.html' %}
{% load static %}
{% block title %}Game View{% endblock %}
{% block content %}

{# Collapsible "view information" #}
<div>
  
<button type="button" class="collapsible">View information</button>
<div class="content">
  <p>
    This game consits of 2 players, both randomly assigned to either a Giver/Follower.
    <br>This project was intented with researching how humans interact and try to guide each other with a disadvantage between each other.
    <br>Both players must interact with the chat box and try to figure out how to guide each other in order to get from the starting path to the end path.
    <br>It is recommended to explain each others maps at the start, and then go on from there, the Giver must pay attention to detail in order to guide the follower as much as they can.
  </p>
</div>
<div>
  your role is:
  {{player.role}}
  {% if player.role == "follower"%}
    you will receive instructions, etc.
  {% else %}
    you will give instructions to the follower, etc.
  {% endif %}
</div>

{# for now just use the room name as the key, can be changed later #}
{% if not public %}
<div> Your private key is: {{room_name}}. Share this with someone else to play together.</div>
{% endif %}
{# Game map and chat #}
<div class="row">
  <canvas id="canvas" class="col-sm-8 game" width="900px" height ="550px">
    <img id="dummy" hidden src="{% static 'images/logo.png' %}">
    <img id="dummy2" hidden src="{% static 'images/player.png' %}"> 
    <img id="dummy3" hidden src = "{% static 'images/blue-rectangle-hi.png' %}">
    <img id="dummy4" hidden src = "{% static 'images/blue-rectangle-hi.png' %}">
    <img id="dummy5" hidden src = "{% static 'images/yellow-box.png' %}">
   </canvas>
     
  <div class="col-sm-4 chat"><div  id="chat-log" ></div><br>
    {# below turns python dict of room name into json to be used in script (see context variable in views.py) #}
    {{ room_name|json_script:"room-name" }}
    </div>
  <div class="col-sm-8"></div>
  <div class="col-sm-4">  
  <input id="chat-message-input" placeholder="Type in here ... " type="text" size="100"><br>
  <input id="chat-message-submit" type="button" value="Send"> 
</div>

{# Buttons #}
<div class="col-sm-8">
  {# input types need to be changed when we implement the different behaviour for finishing the game #}
  <form id = "complete">
    {% csrf_token %}
    <input type="submit" class="btn btn-primary" value="Complete" />
  </form>
  <form id = "complete">
    {% csrf_token %}
    <input type="submit" class="btn btn-primary" value="Give Up" />
  </form>
  <button onclick = "undo()">Undo move</button>
</div>
{{ gameCurr.rects|json_script:"rects" }}
{{ gameCurr.path|json_script:"path" }}
{{ player.role|json_script:"role"}}
{% endblock content %}

{# Collapsible "view information" Javascript function #}
{% block javascript %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/reconnecting-websocket/1.0.0/reconnecting-websocket.min.js" integrity="sha512-B4skI5FiLurS86aioJx9VfozI1wjqrn6aTdJH+YQUmCZum/ZibPBTX55k5d9XM6EsKePDInkLVrN7vPmJxc1qA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
  var rects = JSON.parse(document.getElementById('rects').textContent)
  var path = JSON.parse(document.getElementById('path').textContent)
  var role = JSON.parse(document.getElementById('role').textContent)
  // read the player's role from the Django template 
  var playerRole = "{{ player.role }}";
  // read the player's role from the Django template 
  var coll = document.getElementsByClassName("collapsible");
  var i;
  var rects;
  var player;
  var moveStack = [];
  var imgStack = [];
  var undoTrue = false;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  class Shape {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    intersects(other) {
        return false;
    }
}

class Circle extends Shape {
    constructor(x, y, radius) {
        super(x, y);
        this.radius = radius;
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
    }

    intersects(other) {
        if (other instanceof Circle) {
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            return distance < (this.radius + other.radius);
        } 
        else if (other instanceof Rectangle) {
            const deltaX = this.x - Math.max(other.x, Math.min(this.x, other.x + other.width));
            const deltaY = this.y - Math.max(other.y, Math.min(this.y, other.y + other.height));

            return (deltaX * deltaX + deltaY * deltaY) < (this.radius * this.radius);
        } 
        else if (other instanceof Square) {
            return other.intersects(this);
        }
    }
}

class Rectangle extends Shape {
    constructor(x, y, width, height) {
        super(x, y);
        this.width = width;
        this.height = height;
    }

    draw() {
        ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    intersects(other) {
        if (other instanceof Rectangle) {
            return (
                this.x < other.x + other.width &&
                this.x + this.width > other.x &&
                this.y < other.y + other.height &&
                this.y + this.height > other.y
            );
        } 
        else if (other instanceof Circle) {
            return other.intersects(this);
        } 
        else if (other instanceof Square) {
            
            return other.intersects(this);
        }
    }
}

class Square extends Shape {
    constructor(x, y, side) {
        super(x, y);
        this.side = side;
    }

    draw() {
        ctx.strokeRect(this.x, this.y, this.side, this.side);
    }

    intersects(other) {
        if (other instanceof Rectangle) {
            return (
                this.x < other.x + other.width &&
                this.x + this.side > other.x &&
                this.y < other.y + other.height &&
                this.y + this.side > other.y
            );
        } 
        else if (other instanceof Circle) {
            const deltaX = other.x - Math.max(this.x, Math.min(other.x, this.x + this.side));
            const deltaY = other.y - Math.max(this.y, Math.min(other.y, this.y + this.side));

            return (deltaX * deltaX + deltaY * deltaY) < (other.radius * other.radius);
        } 
        else if (other instanceof Square) {
            return (
                this.x < other.x + other.side &&
                this.x + this.side > other.x &&
                this.y < other.y + other.side &&
                this.y + this.side > other.y
            );
        }
    }
}

function getOffset(el) {
  const rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY
  };
}
    
  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }

  //read the current room name from context in views.py
  const roomName = JSON.parse(document.getElementById('room-name').textContent);

  //create new websocket for chat
  let protocol = (window.location.protocol === 'https:' ? 'wss' : 'ws') + '://';
  const chatSocket = new ReconnectingWebSocket(
    // needs to be a wss connection to work over https
    protocol
    + window.location.host
    + '/ws/all_rooms/game_view/'
    + roomName
    + '/'
  );


  /* after every message, log it in a JSON chat log 
  ---         can be changed later     ---*/
  chatSocket.onmessage = function(e) {
    const data = JSON.parse(e.data);
    // do some more stuff when game finished
    // both see a finished map, either as popup or redirect to new page
    // this will have to change depending on if the game is given up or completed
    if (data.finished == true){
      // this isn't amazing, we need to have a way to show them both the comparison of the maps
      window.location.replace("/home");
      return;
    }
    // Get the current time
    const time = new Date();
    const hours = time.getHours().toString().padStart(2, '0');
    const minutes = time.getMinutes().toString().padStart(2, '0');
    const formattedTime = hours + ':' + minutes;

    // Check if message was sent by current player or other player
    if (data.type == "announcement"){
      document.getElementById('chat-log').innerHTML += "<span class='message chat-sent'>" + data.message + "<br></span>";
    }
    else if (data.role === playerRole) {
      document.getElementById('chat-log').innerHTML += "<span class='message chat-sent'>" + data.role + ": " + data.message + "<br></span>";
    } 
    else if ( data.type == "move" ) {
      rects = data.message[ "rects" ]
      if ( !player ) SpawnPlayer( data.message[ "x" ], data.message[ "y" ] )
      update( data.message )
    }
    else {
      document.getElementById('chat-log').innerHTML += "<span class='message chat-received'>" + data.role + ": " + data.message + "<br></span>";
    }
    // Scroll chat log to bottom
    const chatLog = document.getElementById('chat-log');
    chatLog.scrollTop = chatLog.scrollHeight;
  };
 
  /* do something when the chat socket is closed */
  chatSocket.onclose = function(e) {
    console.log('Socket closed unexpectedly');
  };

  function intersect( r1, r2 ) {
    if( r1.left < r2.left + r2.width && r1.left + r1.width > r2.left &&
     r1.top < r2.top + r2.height && r1.top + r1.height > r2.top ) return true
     return false
  }

  // Some of it will be moved to the server side
  function SpawnPlayer ( x, y ) {

    var gameWindow = document.getElementsByClassName( "game" )

    let img = document.createElement( 'img' )
    img.src = dummy2.src
    img.style.position = "absolute"
    img.style.top = y + "px"
    img.style.left = x + "px"
    img.style.width = "32px"
    img.style.height = "32px"
    img.id = "player"
    img.style.zIndex = 99
    gameWindow[0].appendChild( img )
    player = img
    let data = {}
    $.ajax({
        type: 'POST',
        url: "{% url 'initial_player' %}",
        data: {"x":x,"y":y,"room_name":roomName},
        headers: { "X-CSRFToken": getCookie("csrftoken") },
        success: function (response) {
            data["x"] = x
            data["y"] = y
            update(data)
            return;
          // show them the map drawn compared to the initial map
        }
    })
  }

  function update( data ) {
    let player = document.getElementById( "player" )
    player.style.left = data[ "x" ] + "px";
    player.style.top = data[ "y" ] + "px";
    var gameWindow = document.getElementsByClassName( "game" )
    if (undoTrue != true){
      let img = document.createElement( 'img' )
      img.src = dummy3.src
      img.style.position = "absolute"
      img.style.top = player.style.top
      img.style.left = player.style.left
      img.style.width = 10 + "px"
      img.style.height = 10 + "px"
      imgStack.push(img)
      //img.style.zIndex = -1
      gameWindow[0].appendChild( img ) 
    }
  undoTrue = false
  }
  
  function sendInput( x, y ) {
    moveStack.push({"x":x, "y":y})
    chatSocket.send(JSON.stringify({
          'message': { "x": x, "y": y },
          'role': "move",
          'finished' : false,
        }));
  }

  function undo() {
    undoTrue = true
    lastMove = moveStack.pop()
    lastImg = imgStack.pop()
    lastImg.remove()
    chatSocket.send(JSON.stringify({
          'message': {"x": -lastMove["x"], "y": -lastMove["y"] },
          'role': "move",
          'finished' : false,
        }));
  }
  function InitializeObstacles( rects ) {

    var gameWindow = document.getElementsByClassName( "game" )
    let dummmy = document.getElementById( "dummy" )
    leftOffset = getOffset(gameWindow[0]).left
    topOffset = getOffset(gameWindow[0]).top
    for( let i = 0; i < rects.length; i++ ) {
      const side = rects[i].width
      const xS = rects[i].left
      console.log(xS, rects[i].left)
      const yS = rects[i].top - topOffset
      shape = new Square(xS, yS, side);
      shape.draw();
      /*let img = document.createElement( 'img' )
      img.src = dummy.src
      img.style.position = "absolute"
      img.style.top = rects[i].top + "px"
      img.style.left = rects[i].left + "px"
      img.style.width = rects[i].width + "px"
      img.style.height = rects[i].height + "px"
      //img.style.zIndex = -1
      gameWindow[0].appendChild( img ) */
    }
    

    document.addEventListener( 'keydown', function( event ) {
      if( event.keyCode == 37 ) sendInput( -1, 0 )
      else if( event.keyCode == 39 ) sendInput( 1, 0 )
      else if( event.keyCode == 38 ) sendInput( 0, -1 )
      else if( event.keyCode == 40 ) sendInput( 0, 1 )

      if( [ "Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight" ].indexOf( event.code ) > -1) {
        event.preventDefault();
      }
    } );

  }
  function InitializeFinalPath(path){
    var gameWindow = document.getElementsByClassName( "game" )
    //let dummmy4 = document.getElementById( "dummy4" )
    leftOffset = getOffset(gameWindow[0]).left
    topOffset = getOffset(gameWindow[0]).top
    for( let i = 0; i < path.length; i++ ) {
      const side = path[i].width
      const xS = path[i].left
      console.log(xS, path[i].left)
      const yS = path[i].top - topOffset
      shape = new Square(xS, yS, side);
      shape.draw();
      /*let img = document.createElement( 'img' )
      img.src = dummy4.src
      img.style.position = "absolute"
      img.style.top = path[i].top + "px"
      img.style.left = path[i].left + "px"
      img.style.width = path[i].width + "px"
      img.style.height = path[i].height + "px"
      //img.style.zIndex = -1
      gameWindow[0].appendChild( img ) */
    }
  }

  function initializeStartandEnd(path){
    var gameWindow = document.getElementsByClassName( "game" )
    leftOffset = getOffset(gameWindow[0]).left
    topOffset = getOffset(gameWindow[0]).top
    var side = path[path.length-1].width
    var xS = path[path.length-1].left
    var yS = path[path.length-1].top - topOffset
    shape = new Square(xS, yS, side);
    shape.draw();

    side = path[0].width
    xS = path[0].left
    yS = path[0].top - topOffset
    shape = new Square(xS, yS, side);
    shape.draw();

    shape = new Square(xS, yS, side);
    shape.draw();

    /*var gameWindow = document.getElementsByClassName( "game" )
    let dummmy5 = document.getElementById( "dummy5" )
    let img = document.createElement( 'img' )
    img.src = dummy5.src
    img.style.position = "absolute"
    console.log(path.length - 1)
    console.log(path[path.length-1])
    img.style.top = path[path.length-1].top + "px"
    img.style.left = path[path.length-1].left + "px"
    img.style.width = path[path.length-1].width + "px"
    img.style.height = path[path.length-1].height + "px"
    //img.style.zIndex = -1
    gameWindow[0].appendChild( img )
    img = document.createElement ( 'img' )
    img.src = dummy5.src
    img.style.position = "absolute"
    img.style.top = path[0].top + "px"
    img.style.left = path[0].left + "px"
    img.style.width = path[0].width + "px"
    img.style.height = path[0].height + "px"
    //img.style.zIndex = -1
    gameWindow[0].appendChild( img )*/
    }
  /* allows for submitting messages via pressing enter*/
  document.querySelector('#chat-message-input').focus();
  document.querySelector('#chat-message-input').onkeyup = function(e) {
    if (e.keyCode === 13) {  // enter, return
        document.querySelector('#chat-message-submit').click();
    }
  };

  /* submitting messages sends messages via web socket*/
  document.querySelector('#chat-message-submit').onclick = function(e) {
    const messageInputDom = document.querySelector('#chat-message-input');
    const playerRole = "{{player.role}}";
    const message = messageInputDom.value;
    // some ajax to save the message to database asynchronously
    $.ajax({
        type: 'POST',
        url: "{% url 'save_message' %}",
        data: {"message":message, "role": playerRole, "room_name":roomName},
        headers: { "X-CSRFToken": getCookie("csrftoken") },
        success: function (response) {
          chatSocket.send(JSON.stringify({
          'message': message,
          'role': playerRole,
          'finished' : false
        }));
        },
        error: function (response) {
          // alert the error if any error occured
          alert(response["responseJSON"]["error"]);
        }
    })
    messageInputDom.value = '';
  };

  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

$("#complete").submit(function (e) {
  // tell the group the game has ended
  // NOTE: this has to be changed depending if the game is either given up or completed
    // serialize the data for sending the form data.
    // make POST ajax call
    $.ajax({
        type: 'POST',
        url: "{% url 'complete_game' %}",
        data: {"roomName":roomName},
        headers: { "X-CSRFToken": getCookie("csrftoken") },
        success: function (response) {
          window.location.replace("/home");
          // show them the map drawn compared to the initial map
        },
        error: function (response) {
          // alert the error if any error occured
          console.log(response["responseJSON"]["error"]);
        }
    })
  // game completed, let other players know
  chatSocket.send(JSON.stringify({
      'message': "",
      'role': "",
      'finished' : true
  }));
})
let gameContainer = document.getElementsByClassName( "game" ).item(0)
let rect = gameContainer.getBoundingClientRect();
InitializeObstacles(JSON.parse(rects))
console.log(role)
if (role == "follower"){
  SpawnPlayer(0,rect.top)
  initializeStartandEnd(JSON.parse(path))
}
else{
  InitializeFinalPath(JSON.parse(path))
}

  </script>
{% endblock javascript %}
